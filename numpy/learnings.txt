Numpy ->
- it stands for numeric python 
- An open-source python library built using python and C. 
- NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.

- NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an ndarray will create a new array and delete the original.


Sequential and Non- Sequential Datatypes->

1. Sequential -> Sequential data types are ordered collections of elements that can be accessed using an index. The primary built-in sequence types are lists, tuples, and strings. Other types include range objects, bytes, and bytearray. 

    1. Lists (list)
        -Lists are the most versatile and widely used sequence type. 
        -Mutability: Mutable (can be modified after creation).
        -Definition: Created using square brackets [].
        -Contents: Can store elements of different data types (heterogeneous), including other lists.
        -Use Cases: General-purpose data storage, stacks, queues, and any scenario where elements need to be added, removed, or changed dynamically. 

        my_list = [1, "hello", 3.14, [4, 5]]
        my_list.append("world") # Modifying the list
        print(my_list[1])      # Accessing by index: "hello"


    2. Tuples (tuple)
        -Tuples are similar to lists but are "immutable", meaning their contents cannot be changed after creation. 
        -Mutability: Immutable (cannot be modified).
        -Definition: Created using parentheses () (or just commas).
        -Contents: Can also store heterogeneous elements.
        -Use Cases: Storing data that should not change (e.g., coordinates, database records), returning multiple values from a function, and as keys in dictionaries (lists cannot be dictionary keys because they are mutable). 


        my_tuple = (1, "hello", 3.14)
        # my_tuple[1] = "world" # This would raise a TypeError
        print(my_tuple[0])       # Accessing by index: 1


    3. Strings (str) 
        -Strings are sequences of characters used for storing text. 
        -Mutability: Immutable.
        -Definition: Created using single quotes '', double quotes "", or triple quotes """ """.
        -Contents: Stores data of the str type.
        -Use Cases: Text processing, user interaction, data manipulation. Operations like concatenation create a new string rather than modifying the original. 


        my_string = "Hello, World!"
        # my_string[0] = "J" # This would raise a TypeError
        print(my_string[0])    # Accessing by index: "H"

    4.Other Sequence Types
        -range: Represents an immutable sequence of numbers, primarily used for looping a specific number of times (e.g., range(0, 10)). It is memory-efficient as it generates numbers on demand.

        -bytes and bytearray: These handle binary data. bytes is an immutable sequence of small integers (0-255), while bytearray is its mutable counterpart. 

2. Non-sequential->The primary non-sequential (unordered) data types in Python are dictionaries, sets, and frozensets. These data types do not maintain a specific order for their elements, unlike sequence types such as lists and tuples.

    1.Dictionaries (dict): Dictionaries are collections of key-value pairs.
       - They are unordered, though as of recent Python versions, they maintain insertion order in CPython implementation.
       - Elements are accessed using their unique keys (which must be immutable types like strings or numbers), not by an index.
       - They are mutable, meaning you can add, remove, and change key-value pairs after creation.
       - Example: my_dict = {"name": "Max", "age": 25, "city": "Berlin"}

    2.Sets (set): Sets are unordered collections of unique elements.
       - They do not allow duplicate items and are ideal for membership testing and removing duplicates from a sequence.
       - Sets are mutable.
       - Example: unique_numbers = {1, 2, 3, 4, 5}

    3.Frozensets (frozenset): Frozensets are immutable versions of sets.
       - Once a frozenset is created, its elements cannot be changed, added, or removed.
       - Example: frozen_set = frozenset([1, 2, 3, 4, 5])         

Features of Numpy - 

1. N-dimensional array - multi dimensional array.
  0-dimensional aaray - scaler
  1-dimensional array - vector
  2-dimensional arrat - Matrix
  3-dimensional array - Tensor
  .
  ..... - Al are tensor 

  An N-dimensional array is a data structure that stores elements in N dimensions (or axes) instead of just one or two.


1Ô∏è‚É£ Creating Arrays using np.array

1D Array

import numpy as np

a = np.array([1, 2, 3, 4, 5, 6])
print(a)


‚∏ª

2D Array

b = np.array([[1, 2, 3],[4, 5, 6]])
print(b)


‚∏ª

3D Array

c = np.array([[[1, 2, 3],[4, 5, 6]]])
print(c)


‚∏ª

2Ô∏è‚É£ Array Properties

a.ndim    # number of dimensions
a.shape   # shape of array
a.size    # total elements
a.dtype   # data type


‚∏ª

3Ô∏è‚É£ Normal Slicing (Like Python Lists)

‚∏ª

1D Slicing

a = np.array([10, 20, 30, 40, 50])

a[0]      # 10
a[1:4]    # [20 30 40]
a[-1]     # 50


‚∏ª

2D Slicing

b = np.array([[1, 2, 3],[4, 5, 6]])

b[0]        # [1 2 3]
b[1, 2]     # 6
b[:, 1]     # [2 5]


‚∏ª

3D Slicing

c = np.array([[[1, 2],[3, 4]],[[5, 6],[7, 8]]])

c[0]           # 2D block
c[0, 1]        # [3 4]
c[1, 0, 1]     # 6


‚∏ª

4Ô∏è‚É£ Reshaping Arrays

‚∏ª

1D ‚Üí 2D

a = np.array([1, 2, 3, 4, 5, 6])
a2 = a.reshape(2, 3)
print(a2)


‚∏ª

2D ‚Üí 3D

a3 = a.reshape(1, 2, 3)
print(a3)


‚∏ª

1D ‚Üí 4D

a4 = np.array(range(16)).reshape(2, 2, 2, 2)
print(a4)


‚∏ª

Automatic Reshape using -1

x = np.array([1,2,3,4,5,6,7,8])
y = x.reshape(2, -1)
print(y)


‚∏ª

5Ô∏è‚É£ Slicing After Reshape (Very Important)

d = np.array(range(16)).reshape(2, 2, 2, 2)

d[0]            # 3D array
d[0, 1]         # 2D array
d[0, 1, 0]      # 1D array
d[0, 1, 0, 1]   # single element


‚∏ª

6Ô∏è‚É£ Golden Rule of Indexing

arr[i][j][k][l]  ==  arr[i, j, k, l]


‚∏ª

7Ô∏è‚É£ Common Mistakes ‚ùå

a.reshape(2, 4)   # ‚ùå if total elements don't match
a[0[1]]           # ‚ùå wrong bracket usage


‚∏ª

8Ô∏è‚É£ Quick Summary Table

Dimension	 Name	  Example
1D.      	Vector	  [1,2,3]
2D	        Matrix	  [[1,2],[3,4]]
3D+	        Tensor	   ML, AI, 



‚∏ª

üìò NumPy Array Initialization

‚∏ª

1Ô∏è‚É£ Using np.array() (Manual Initialization)

import numpy as np

a = np.array([1, 2, 3, 4])
b = np.array([[1, 2], [3, 4]])
c = np.array([[[1, 2], [3, 4]]])


‚∏ª

2Ô∏è‚É£ Initialize with Zeros

np.zeros(5)          # 1D
np.zeros((2, 3))      # 2D
np.zeros((2, 2, 2))   # 3D


‚∏ª

3Ô∏è‚É£ Initialize with Ones

np.ones(4)
np.ones((3, 3))
np.ones((2, 2, 2))


‚∏ª

4Ô∏è‚É£ Initialize with Constant Value

np.full((2, 3), 7)


‚∏ª

5Ô∏è‚É£ Identity Matrix

np.eye(3)     # 3x3 identity matrix


‚∏ª

6Ô∏è‚É£ Range Initialization

Using arange()

np.arange(10)
np.arange(1, 10, 2)


‚∏ª

Using linspace()

np.linspace(0, 1, 5)


‚∏ª

7Ô∏è‚É£ Random Initialization

Random floats (0 to 1)

np.random.rand(3, 3)


‚∏ª

Random integers

np.random.randint(1, 10, (2, 3))


‚∏ª

Normal distribution

np.random.randn(3, 3)


‚∏ª

8Ô∏è‚É£ Empty Array (Fast, garbage values)

np.empty((2, 3))


‚∏ª

9Ô∏è‚É£ Like Another Array

a = np.array([[1, 2], [3, 4]])

np.zeros_like(a)
np.ones_like(a)
np.full_like(a, 9)


‚∏ª

üîü Initialize then Reshape

a = np.arange(12).reshape(3, 4)


‚∏ª

1Ô∏è‚É£1Ô∏è‚É£ Data Type Initialization

np.array([1, 2, 3], dtype=float)
np.zeros((2, 2), dtype=int)


‚∏ª

‚úÖ Summary Table

Method	Use -

np.array()	manual values
zeros()	     initialize with 0
ones()	     initialize with 1
full()	     constant value
eye()	     identity matrix
arange()	 range
linspace()	 evenly spaced
rand()	     random floats
randint()	 random ints
empty()	     fast allocation
 

